/* eslint-disable @typescript-eslint/no-explicit-any */
const files = new Map();
export function FileAttachment(name, base = document.baseURI) {
    if (new.target !== undefined)
        throw new TypeError("FileAttachment is not a constructor");
    const href = new URL(name, base).href;
    let file = files.get(href);
    if (!file) {
        file = new FileAttachmentImpl(href, name.split("/").pop());
        files.set(href, file);
    }
    return file;
}
async function remote_fetch(file) {
    const response = await fetch(file.href);
    if (!response.ok)
        throw new Error(`Unable to load file: ${file.name}`);
    return response;
}
export class AbstractFile {
    constructor(name, mimeType = guessMimeType(name), lastModified, size) {
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mimeType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastModified", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperties(this, {
            name: { value: `${name}`, enumerable: true },
            mimeType: { value: `${mimeType}`, enumerable: true },
            lastModified: { value: lastModified === undefined ? undefined : +lastModified, enumerable: true }, // prettier-ignore
            size: { value: size === undefined ? undefined : +size, enumerable: true }
        });
    }
    async url() {
        return this.href;
    }
    async blob() {
        return (await remote_fetch(this)).blob();
    }
    async arrayBuffer() {
        return (await remote_fetch(this)).arrayBuffer();
    }
    async text(encoding) {
        return encoding === undefined
            ? (await remote_fetch(this)).text()
            : new TextDecoder(encoding).decode(await this.arrayBuffer());
    }
    async json() {
        return (await remote_fetch(this)).json();
    }
    async stream() {
        return (await remote_fetch(this)).body;
    }
    async dsv({ delimiter = ",", array = false, typed = false } = {}) {
        const [text, d3] = await Promise.all([this.text(), import("npm:d3-dsv")]);
        const format = d3.dsvFormat(delimiter);
        const parse = array ? format.parseRows : format.parse;
        return parse(text, typed && d3.autoType);
    }
    async csv(options) {
        return this.dsv({ ...options, delimiter: "," });
    }
    async tsv(options) {
        return this.dsv({ ...options, delimiter: "\t" });
    }
    async image(props) {
        const url = await this.url();
        return new Promise((resolve, reject) => {
            const i = new Image();
            if (new URL(url, document.baseURI).origin !== location.origin)
                i.crossOrigin = "anonymous";
            Object.assign(i, props);
            i.onload = () => resolve(i);
            i.onerror = () => reject(new Error(`Unable to load file: ${this.name}`));
            i.src = url;
        });
    }
    async arrow() {
        const [Arrow, response] = await Promise.all([import("npm:apache-arrow"), remote_fetch(this)]);
        return Arrow.tableFromIPC(response);
    }
    async arquero(options) {
        let request;
        let from;
        switch (this.mimeType) {
            case "application/json":
                request = this.text();
                from = "fromJSON";
                break;
            // @ts-expect-error fall through
            case "text/tab-separated-values":
                if (options?.delimiter === undefined)
                    options = { ...options, delimiter: "\t" };
            // fall through
            case "text/csv":
                request = this.text();
                from = "fromCSV";
                break;
            default:
                if (/\.arrow$/i.test(this.name)) {
                    request = this.arrow();
                    from = "fromArrow";
                }
                else if (/\.parquet$/i.test(this.name)) {
                    request = this.parquet();
                    from = "fromArrow";
                }
                else {
                    throw new Error(`unable to determine Arquero loader: ${this.name}`);
                }
                break;
        }
        const [aq, body] = await Promise.all([import("npm:arquero"), request]);
        return aq[from](body, options);
    }
    async parquet() {
        const [Arrow, Parquet, buffer] = await Promise.all([import("npm:apache-arrow"), import("npm:parquet-wasm").then(async (Parquet) => (await Parquet.default("https://cdn.jsdelivr.net/npm/parquet-wasm/esm/parquet_wasm_bg.wasm"), Parquet)), this.arrayBuffer()]); // prettier-ignore
        return Arrow.tableFromIPC(Parquet.readParquet(new Uint8Array(buffer)).intoIPCStream());
    }
    async xml(mimeType = "application/xml") {
        return new DOMParser().parseFromString(await this.text(), mimeType);
    }
    async html() {
        return this.xml("text/html");
    }
}
// TODO Replace this with static analysis of files.
function guessMimeType(name) {
    const i = name.lastIndexOf(".");
    const j = name.lastIndexOf("/");
    const extension = i > 0 && (j < 0 || i > j) ? name.slice(i).toLowerCase() : "";
    switch (extension) {
        case ".csv":
            return "text/csv";
        case ".tsv":
            return "text/tab-separated-values";
        case ".json":
            return "application/json";
        case ".html":
            return "text/html";
        case ".xml":
            return "application/xml";
        case ".png":
            return "image/png";
        case ".jpg":
            return "image/jpg";
        case ".js":
            return "text/javascript";
        default:
            return "application/octet-stream";
    }
}
class FileAttachmentImpl extends AbstractFile {
    constructor(href, name, mimeType, lastModified, size) {
        super(name, mimeType, lastModified, size);
        Object.defineProperty(this, "href", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "href", { value: href });
    }
}
Object.defineProperty(FileAttachmentImpl, "name", { value: "FileAttachment" }); // prevent mangling
FileAttachment.prototype = FileAttachmentImpl.prototype; // instanceof
export function fileAttachments(resolve) {
    function FileAttachment(name) {
        const result = resolve((name += ""));
        if (result == null)
            throw new Error(`File not found: ${name}`);
        if (typeof result === "object" && "url" in result) {
            const { url, mimeType } = result;
            return new FileAttachmentImpl(url, name, mimeType);
        }
        return new FileAttachmentImpl(result, name);
    }
    FileAttachment.prototype = FileAttachmentImpl.prototype; // instanceof
    return FileAttachment;
}
