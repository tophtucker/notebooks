import { inspect, inspectError, getExpanded } from "./inspect.js";
import { mapAssets } from "./stdlib/assets.js";
export function display(state, value) {
    const { root, expanded } = state;
    const node = isDisplayable(value, root) ? value : inspect(value, expanded[root.childNodes.length]); // prettier-ignore
    displayNode(state, node);
}
function displayNode(state, node) {
    if (node.nodeType === 11) {
        let child;
        while ((child = node.firstChild)) {
            state.root.appendChild(child);
        }
    }
    else {
        state.root.appendChild(node);
    }
}
function displayError(state, value) {
    displayNode(state, inspectError(value));
}
// Note: Element.prototype is instanceof Node, but cannot be inserted! This
// excludes DocumentFragment since appending a fragment “dissolves” (mutates)
// the fragment, and we wish for the inspector to not have side-effects.
function isDisplayable(value, root) {
    return ((value instanceof Element || value instanceof Text) &&
        value instanceof value.constructor &&
        (!value.parentNode || root.contains(value)));
}
export function clear(state) {
    state.expanded = Array.from(state.root.childNodes, getExpanded);
    while (state.root.lastChild)
        state.root.lastChild.remove();
}
export function observe(state, { autodisplay, assets }) {
    return {
        _error: false,
        _node: state.root, // _node for visibility promise
        pending() {
            if (this._error) {
                this._error = false;
                clear(state);
            }
        },
        fulfilled(value) {
            if (autodisplay) {
                clear(state);
                if (assets && value instanceof Element)
                    mapAssets(value, assets);
                display(state, value);
            }
        },
        rejected(error) {
            console.error(error);
            this._error = true;
            clear(state);
            displayError(state, error);
        }
    };
}
