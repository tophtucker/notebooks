import { resolveJsrImport } from "./imports/jsr.js";
import { resolveNpmImport } from "./imports/npm.js";
import { resolveObservableImport } from "./imports/observable.js";
import { isObservableImport, renderObservableImport } from "./imports/observable.js";
import { getStringLiteralValue, isStringLiteral } from "./strings.js";
import { syntaxError } from "./syntaxError.js";
import { simple } from "./walk.js";
/** Throws a syntax error if any export declarations are found. */
export function checkExports(body, input) {
    function checkExport(child) {
        throw syntaxError("Unexpected token 'export'", child, input);
    }
    simple(body, {
        ExportAllDeclaration: checkExport,
        ExportNamedDeclaration: checkExport
    });
}
/** Returns true if the body includes an import declaration. */
export function hasImportDeclaration(body) {
    let has = false;
    simple(body, {
        ImportDeclaration() {
            has = true;
        }
    });
    return has;
}
/** Returns true if the given node is a import.meta.resolve(â€¦) call. */
export function isImportMetaResolve(node) {
    return (node.callee.type === "MemberExpression" &&
        node.callee.object.type === "MetaProperty" &&
        node.callee.object.meta.name === "import" &&
        node.callee.object.property.name === "meta" &&
        node.callee.property.type === "Identifier" &&
        node.callee.property.name === "resolve" &&
        node.arguments.length > 0);
}
/** Returns true if the given node is a import.meta.url expression. */
export function isImportMetaUrl(node) {
    return (node.object.type === "MetaProperty" &&
        node.object.meta.name === "import" &&
        node.object.property.name === "meta" &&
        node.property.type === "Identifier" &&
        node.property.name === "url");
}
function resolveImport(specifier) {
    return resolveObservableImport(resolveJsrImport(resolveNpmImport(specifier)));
}
export function rewriteImportExpressions(output, body, { resolveLocalImports } = {}) {
    function rewriteImportSource(source, node = source) {
        const value = getStringLiteralValue(source);
        const resolution = resolveImport(value);
        output.replaceLeft(node.start, node.end, resolveLocalImports && isLocalImport(resolution)
            ? `new URL(${JSON.stringify(resolution)}, document.baseURI).href`
            : JSON.stringify(resolution));
    }
    simple(body, {
        ImportExpression(node) {
            const source = node.source;
            if (isStringLiteral(source)) {
                rewriteImportSource(source);
            }
        },
        MemberExpression(node) {
            if (resolveLocalImports && isImportMetaUrl(node)) {
                output.replaceLeft(node.start, node.end, "document.baseURI");
            }
        },
        CallExpression(node) {
            const source = node.arguments[0];
            if (isImportMetaResolve(node) && isStringLiteral(source)) {
                rewriteImportSource(source, node);
            }
        }
    });
}
/** Note: mutates inputs! */
export function rewriteImportDeclarations(output, body, inputs, { resolveLocalImports } = {}) {
    const declarations = [];
    simple(body, {
        ImportDeclaration(node) {
            if (isStringLiteral(node.source)) {
                declarations.push([node, node.source]);
            }
        }
    });
    const specifiers = [];
    const imports = [];
    for (const [node, source] of declarations) {
        output.delete(node.start, node.end + +(output.input[node.end] === "\n"));
        specifiers.push(rewriteImportSpecifiers(node));
        const value = getStringLiteralValue(source);
        const resolution = resolveImport(value);
        imports.push(isObservableImport(node, value)
            ? renderObservableImport(resolution, node, inputs)
            : renderImport(resolveLocalImports && isLocalImport(resolution)
                ? `new URL(${JSON.stringify(resolution)}, document.baseURI)`
                : JSON.stringify(resolution), node, output.input));
    }
    if (declarations.length > 1) {
        output.insertLeft(0, `const [${specifiers.join(", ")}] = await Promise.all([${imports.join(", ")}]);\n`);
    }
    else if (declarations.length === 1) {
        output.insertLeft(0, `const ${specifiers[0]} = await ${imports[0]};\n`);
    }
}
function renderImport(source, node, input) {
    const names = node.specifiers.filter(isNamedSpecifier).map(getImportedName);
    return `import(${source}${node.attributes.length > 0
        ? `, {with: {${input.slice(node.attributes[0].start, node.attributes[node.attributes.length - 1].end)}}}`
        : ""})${names.length > 0
        ? `.then((module) => {${names.map((name) => `
  if (!("${name}" in module)) throw new SyntaxError(\`export '${name}' not found\`);`).join("")}
  return module;
})`
        : ""}`;
}
function getLocalName(node) {
    return node.local.name;
}
export function getImportedName(node) {
    return node.type === "ImportDefaultSpecifier"
        ? "default"
        : node.imported.type === "Identifier"
            ? node.imported.name
            : node.imported.raw;
}
function isLocalImport(source) {
    return ["./", "../", "/"].some((prefix) => source.startsWith(prefix));
}
function isNamespaceSpecifier(node) {
    return node.type === "ImportNamespaceSpecifier";
}
function isNamedSpecifier(node) {
    return node.type !== "ImportNamespaceSpecifier";
}
function rewriteImportSpecifiers(node) {
    return node.specifiers.some(isNamedSpecifier)
        ? `{${node.specifiers.filter(isNamedSpecifier).map(rewriteImportSpecifier).join(", ")}}`
        : (node.specifiers.find(isNamespaceSpecifier)?.local.name ?? "{}");
}
function rewriteImportSpecifier(node) {
    return getImportedName(node) === getLocalName(node)
        ? getLocalName(node)
        : `${getImportedName(node)}: ${getLocalName(node)}`;
}
