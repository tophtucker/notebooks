import { Parser, tokTypes } from "acorn";
import { checkExports } from "./imports.js";
import { findReferences } from "./references.js";
import { checkAssignments } from "./assignments.js";
import { findDeclarations } from "./declarations.js";
import { findAwaits } from "./awaits.js";
export const acornOptions = {
    ecmaVersion: "latest",
    sourceType: "module"
};
export function maybeParseJavaScript(input) {
    try {
        return parseJavaScript(input);
    }
    catch (error) {
        if (!(error instanceof SyntaxError))
            throw error;
        return;
    }
}
export function parseJavaScript(input) {
    let expression = maybeParseExpression(input); // first attempt to parse as expression
    if (expression?.type === "ClassExpression" && expression.id)
        expression = null; // treat named class as program
    if (expression?.type === "FunctionExpression" && expression.id)
        expression = null; // treat named function as program
    const body = expression ?? parseProgram(input); // otherwise parse as a program
    checkExports(body, input);
    const references = findReferences(body);
    checkAssignments(body, references, input);
    return {
        body,
        declarations: expression ? null : findDeclarations(body, input),
        references,
        expression: !!expression,
        async: findAwaits(body).length > 0
    };
}
function parseProgram(input) {
    return Parser.parse(input, acornOptions);
}
function maybeParseExpression(input) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const parser = new Parser(acornOptions, input, 0); // private constructor
    parser.nextToken();
    try {
        const node = parser.parseExpression();
        return parser.type === tokTypes.eof ? node : null;
    }
    catch {
        return null;
    }
}
